 [] () -12.43e-44 +12.e+3 34e2 1119 .55e-17 -12345
 abcd_23 '1234'
#un commentaire

##
  @function compute_barycenter
  
  @argument mesh
    A mesh M of simplices in N_dim dimensions, with N_dim = 1, 2 or 3.
    We note N_nodes the number of nodes of M, and N_elems the number of elements
    of M.
  @return
    An array(N_elems, N_dim) which stores on each line the coordinate of the
    barycenter of the corresponding element of M.

  @example Compute the barycenters of a unit square
    For the purpose of this example, we create the mesh
    of a unit square. By default, the mesh returned by mesh/make_unit_square
    is made of quadrangles. To satisfy compute_barycenter's requirement, we
    convert the square's unique quadrangle to two triangles::

      var square = mesh/make_unit_square(1, 1);
      square = square::to_simplices;

    Then we can call compute_barycenter with mesh as the only argument::

      var square_barycenters = compute_barycenter(square);

    square_barycenters is now an array(2, 2) which contains [1/3, 1/3; 2/3, 2/3].
## 
##
(function compute_barycenter (mesh)
  (if
    (not mesh::is_simplicial)
    (error "Mesh provided to compute barycenter must be simplicial."))
  (let barycenter (make_array 
                    (mesh element_number)
                    (mesh embedding_dimension)))
  (let node_per_elem (plus (mesh embedding_dimension) 1))
  (for_range elem 0 (minus (mesh element_number) 1)
    (for_range node 0 (plus node_per_elem 1))
    (accumulate (barycenter elem all) (divide ((mesh nodes) ((mesh elem) elem node) all) node-per-elem)))
  barycenter)


function compute_barycenter(mesh)
  var barycenter = array(mesh::element_number,
                         mesh::embedding_dimension);
  barycenter::set(0);

  var nodes_per_elem = mesh::embedding_dimension + 1;

  for elem 0 mesh::element_number - 1
    for node 0 nodes_per_elem
      barycenter[elem, :] += mesh::nodes[mesh::elements[elem, node], :] / nodes_per_elem;
    end
  end

  barycenter;
end

var square = mesh/make_unit_square(10, 10);
square = square::to_simplices;
var border = square::boundary;

var dbc = border::interpolate(function(x, y) 0. end);

var fe = lagrange_finite_element(1);
var Uh = finite_element_space(square, fe, dbc);
var Vh = finite_element_space(square, fe, dbc);

bilinear_form A(uh, vh) integrate(sigma * (uh::d(1)*vh::d(1) + uh::d(2)*vh::d(2)), square);
linear_form b(v) 0 * v;

var matrix_a = assemble_system(A, Uh, Vh);
var rhs_b = assemble_rhs(b, Vh);

var p1_function = Uh::interpolate(function(x, y) x*x + y*y end);

##


( [ ] )
